import { ValidationService, ValidateError, TsoaRoute, FieldErrors } from '@tsoa/runtime';

const models: TsoaRoute.Models = {
    {{#each models}}
    "{{@key}}": {
        {{#if enums}}
        "dataType": "refEnum",
        "enums": {{{json enums}}},
        {{/if}}
        {{#if properties}}
        "dataType": "refObject",
        "properties": {
            {{#each properties}}
            "{{@key}}": {{{json this}}},
            {{/each}}
        },
        "additionalProperties": {{{json additionalProperties}}},
        {{/if}}
        {{#if type}}
        "dataType": "refAlias",
        "type": {{{json type}}},
        {{/if}}
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file: https://github.com/lukeautry/tsoa
    {{/each}}
};

const validationService = new ValidationService(models, {{{json minimalSwaggerConfig}}});

export function getValidatedArgs(args: any, event: any): any[] {
    const fieldErrors: FieldErrors  = {};
    const eventBody = JSON.parse(event.body);
    const values = Object.keys(args).map((key) => {
        const name = args[key].name;
        switch (args[key].in) {
            case 'request':
                return event;
            case 'request-prop':
                return validationService.ValidateParam(args[key], event[name], name, fieldErrors, false, undefined);
            case 'query':
                return validationService.ValidateParam(args[key], event.queryStringParameters[name], name, fieldErrors, false, undefined);
            case 'path':
                return validationService.ValidateParam(args[key], event.pathParameters[name], name, fieldErrors, false, undefined);
            case 'header':
                return validationService.ValidateParam(args[key], event.headers[name], name, fieldErrors, false, undefined);
            case 'body': {
                const bodyFieldErrors: FieldErrors = {};
                const bodyArgs = validationService.ValidateParam(args[key], eventBody, name, bodyFieldErrors, true, undefined);
                Object.keys(bodyFieldErrors).forEach((key) => {
                  fieldErrors[key] = { message: bodyFieldErrors[key].message }
                });
                return bodyArgs;
            }
            case 'body-prop': {
                const bodyPropFieldErrors: FieldErrors = {};
                const bodyPropArgs = validationService.ValidateParam(args[key], eventBody[name], name, bodyPropFieldErrors, true, 'body.');
                Object.keys(bodyPropFieldErrors).forEach((key) => {
                  fieldErrors[key] = { message: bodyPropFieldErrors[key].message }
                });
                return bodyPropArgs;
            }
            case 'formData':
                throw new Error('Multi-part form data not supported yet');
            case 'res':
                throw new Error('Unsupported parameter type "res"');
        }
    });

    if (Object.keys(fieldErrors).length > 0) {
        throw new ValidateError(fieldErrors, '');
    }
    return values;
}
